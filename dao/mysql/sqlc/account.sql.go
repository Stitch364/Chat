// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: account.sql

package db

import (
	"context"
	"database/sql"
	"time"
)

const countAccountsByUserID = `-- name: CountAccountsByUserID :one
select count(id)
from accounts
where user_id = ?
`

// {user_id:int64}
func (q *Queries) CountAccountsByUserID(ctx context.Context, userID int64) (int64, error) {
	row := q.queryRow(ctx, q.countAccountsByUserIDStmt, countAccountsByUserID, userID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createAccount = `-- name: CreateAccount :exec
insert into accounts (id, user_id, name, avatar, gender, signature)
values (?, ?, ?, ?, ?, ?)
`

type CreateAccountParams struct {
	ID        int64
	UserID    int64
	Name      string
	Avatar    string
	Gender    AccountsGender
	Signature string
}

// {id:int64, user_id:int64, name:string, avatar:string, gender:string, signature:string}
func (q *Queries) CreateAccount(ctx context.Context, arg *CreateAccountParams) error {
	_, err := q.exec(ctx, q.createAccountStmt, createAccount,
		arg.ID,
		arg.UserID,
		arg.Name,
		arg.Avatar,
		arg.Gender,
		arg.Signature,
	)
	return err
}

const deleteAccount = `-- name: DeleteAccount :exec
delete
from accounts
where id = ?
`

// {id:int64}
func (q *Queries) DeleteAccount(ctx context.Context, id int64) error {
	_, err := q.exec(ctx, q.deleteAccountStmt, deleteAccount, id)
	return err
}

const deleteAccountsByUserID = `-- name: DeleteAccountsByUserID :exec
delete
from accounts
where user_id = ?
`

// {user_id:int64}
func (q *Queries) DeleteAccountsByUserID(ctx context.Context, userID int64) error {
	_, err := q.exec(ctx, q.deleteAccountsByUserIDStmt, deleteAccountsByUserID, userID)
	return err
}

const existsAccountByID = `-- name: ExistsAccountByID :one
select exists(select 1 from accounts where id = ?)
`

// {id:int64}
func (q *Queries) ExistsAccountByID(ctx context.Context, id int64) (bool, error) {
	row := q.queryRow(ctx, q.existsAccountByIDStmt, existsAccountByID, id)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const existsAccountByNameAndUserID = `-- name: ExistsAccountByNameAndUserID :one
select exists(
    select 1
    from accounts
    where user_id = ?
      and name = ?
)
`

type ExistsAccountByNameAndUserIDParams struct {
	UserID int64
	Name   string
}

// {user_id:int64, name:string}
func (q *Queries) ExistsAccountByNameAndUserID(ctx context.Context, arg *ExistsAccountByNameAndUserIDParams) (bool, error) {
	row := q.queryRow(ctx, q.existsAccountByNameAndUserIDStmt, existsAccountByNameAndUserID, arg.UserID, arg.Name)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const getAccountByID = `-- name: GetAccountByID :one
select a.id, a.user_id, a.name, a.avatar, a.gender, a.signature, a.created_at, r.id as relation_id
from (select id, user_id, name, avatar, gender, signature, created_at from accounts where accounts.id = ?) a
         left join relations r on
    r.relation = 'friend' and
    r.account1_id = a.id and r.account2_id = ? or
    r.account1_id = ? and r.account2_id = a.id
limit 1
`

type GetAccountByIDParams struct {
	ID         int64
	Account2ID sql.NullInt64
	Account1ID sql.NullInt64
}

type GetAccountByIDRow struct {
	ID         int64
	UserID     int64
	Name       string
	Avatar     string
	Gender     AccountsGender
	Signature  string
	CreatedAt  time.Time
	RelationID sql.NullInt64
}

// {accounts.id:int64, r.account2_id:int64, r.account1_id:int64}
func (q *Queries) GetAccountByID(ctx context.Context, arg *GetAccountByIDParams) (*GetAccountByIDRow, error) {
	row := q.queryRow(ctx, q.getAccountByIDStmt, getAccountByID, arg.ID, arg.Account2ID, arg.Account1ID)
	var i GetAccountByIDRow
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Name,
		&i.Avatar,
		&i.Gender,
		&i.Signature,
		&i.CreatedAt,
		&i.RelationID,
	)
	return &i, err
}

const getAccountsByName = `-- name: GetAccountsByName :many
select a.id, a.name, a.avatar, a.gender, r.id as relation_id, count(*) over () as total
from (select id, name, avatar, gender from accounts where accounts.name like CONCAT('%', ?, '%')) as a
         left join relations r on (r.relation = 'friend' and
                                   ((r.account1_id = a.id and r.account2_id = ?) or
                                    (r.account1_id = ? and r.account2_id = a.id)))
limit ? offset ?
`

type GetAccountsByNameParams struct {
	CONCAT     interface{}
	Account2ID sql.NullInt64
	Account1ID sql.NullInt64
	Limit      int32
	Offset     int32
}

type GetAccountsByNameRow struct {
	ID         int64
	Name       string
	Avatar     string
	Gender     AccountsGender
	RelationID sql.NullInt64
	Total      interface{}
}

// {name:string, user_id:int64, page:int64, page_size:int64}
func (q *Queries) GetAccountsByName(ctx context.Context, arg *GetAccountsByNameParams) ([]*GetAccountsByNameRow, error) {
	rows, err := q.query(ctx, q.getAccountsByNameStmt, getAccountsByName,
		arg.CONCAT,
		arg.Account2ID,
		arg.Account1ID,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetAccountsByNameRow{}
	for rows.Next() {
		var i GetAccountsByNameRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Avatar,
			&i.Gender,
			&i.RelationID,
			&i.Total,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAccountsByUserID = `-- name: GetAccountsByUserID :many
select id, name, avatar, gender
from accounts
where user_id = ?
`

type GetAccountsByUserIDRow struct {
	ID     int64
	Name   string
	Avatar string
	Gender AccountsGender
}

// {user_id:int64}
func (q *Queries) GetAccountsByUserID(ctx context.Context, userID int64) ([]*GetAccountsByUserIDRow, error) {
	rows, err := q.query(ctx, q.getAccountsByUserIDStmt, getAccountsByUserID, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetAccountsByUserIDRow{}
	for rows.Next() {
		var i GetAccountsByUserIDRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Avatar,
			&i.Gender,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateAccount = `-- name: UpdateAccount :exec
update accounts
set name        = ?,
    gender      = ?,
    signature   = ?
where id = ?
`

type UpdateAccountParams struct {
	Name      string
	Gender    AccountsGender
	Signature string
	ID        int64
}

// {id:int64, name:string, gender:string, signature:string}
func (q *Queries) UpdateAccount(ctx context.Context, arg *UpdateAccountParams) error {
	_, err := q.exec(ctx, q.updateAccountStmt, updateAccount,
		arg.Name,
		arg.Gender,
		arg.Signature,
		arg.ID,
	)
	return err
}

const updateAccountAvatar = `-- name: UpdateAccountAvatar :exec
update accounts
set avatar = ?
where id = ?
`

type UpdateAccountAvatarParams struct {
	Avatar string
	ID     int64
}

// {id:int64, avatar:string}
func (q *Queries) UpdateAccountAvatar(ctx context.Context, arg *UpdateAccountAvatarParams) error {
	_, err := q.exec(ctx, q.updateAccountAvatarStmt, updateAccountAvatar, arg.Avatar, arg.ID)
	return err
}
