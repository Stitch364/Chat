// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: message.sql

package db

import (
	"context"
	"database/sql"
	"encoding/json"
	"time"
)

const createMessage = `-- name: CreateMessage :exec
insert into messages
(notify_type, msg_type, msg_content, msg_extend, file_id, account_id, rly_msg_id, relation_id)
values
(?,?,?,JSON_ARRAY(),?,?,?,?)
`

type CreateMessageParams struct {
	NotifyType MessagesNotifyType
	MsgType    MessagesMsgType
	MsgContent string
	FileID     sql.NullInt64
	AccountID  sql.NullInt64
	RlyMsgID   sql.NullInt64
	RelationID int64
}

// {notify_type:string,msg_type:string}
func (q *Queries) CreateMessage(ctx context.Context, arg *CreateMessageParams) error {
	_, err := q.exec(ctx, q.createMessageStmt, createMessage,
		arg.NotifyType,
		arg.MsgType,
		arg.MsgContent,
		arg.FileID,
		arg.AccountID,
		arg.RlyMsgID,
		arg.RelationID,
	)
	return err
}

const createMessageReturn = `-- name: CreateMessageReturn :one
SELECT
    id, msg_content, COALESCE(msg_extend,'{}'), file_id, create_at
FROM messages
WHERE id = LAST_INSERT_ID()
`

type CreateMessageReturnRow struct {
	ID         int64
	MsgContent string
	MsgExtend  json.RawMessage
	FileID     sql.NullInt64
	CreateAt   time.Time
}

func (q *Queries) CreateMessageReturn(ctx context.Context) (*CreateMessageReturnRow, error) {
	row := q.queryRow(ctx, q.createMessageReturnStmt, createMessageReturn)
	var i CreateMessageReturnRow
	err := row.Scan(
		&i.ID,
		&i.MsgContent,
		&i.MsgExtend,
		&i.FileID,
		&i.CreateAt,
	)
	return &i, err
}

const getAccountIDsByMsgID = `-- name: GetAccountIDsByMsgID :one
select account1_id, account2_id
from relations r
where r.id = (
    select relation_id
    from messages m
    where m.id = ?
)
limit 1
`

type GetAccountIDsByMsgIDRow struct {
	Account1ID sql.NullInt64
	Account2ID sql.NullInt64
}

func (q *Queries) GetAccountIDsByMsgID(ctx context.Context, id int64) (*GetAccountIDsByMsgIDRow, error) {
	row := q.queryRow(ctx, q.getAccountIDsByMsgIDStmt, getAccountIDsByMsgID, id)
	var i GetAccountIDsByMsgIDRow
	err := row.Scan(&i.Account1ID, &i.Account2ID)
	return &i, err
}

const getAccountInfoByID = `-- name: GetAccountInfoByID :one
select accounts.name,accounts.avatar,settings.nick_name
from accounts
join settings on accounts.id = settings.account_id  and relation_id = ?
where account_id = ?
`

type GetAccountInfoByIDParams struct {
	RelationID int64
	AccountID  int64
}

type GetAccountInfoByIDRow struct {
	Name     string
	Avatar   string
	NickName string
}

func (q *Queries) GetAccountInfoByID(ctx context.Context, arg *GetAccountInfoByIDParams) (*GetAccountInfoByIDRow, error) {
	row := q.queryRow(ctx, q.getAccountInfoByIDStmt, getAccountInfoByID, arg.RelationID, arg.AccountID)
	var i GetAccountInfoByIDRow
	err := row.Scan(&i.Name, &i.Avatar, &i.NickName)
	return &i, err
}

const getMessageAndNameByID = `-- name: GetMessageAndNameByID :one
select m.id, notify_type, msg_type, msg_content, coalesce(msg_extend,'[]'), file_id, m.account_id,a.name,s.nick_name,a.avatar,
       rly_msg_id, m.relation_id, create_at, is_revoke, is_top, m.is_pin, m.pin_time, read_ids, is_delete
from messages m
join accounts a on a.id = m.account_id
join settings s on s.account_id  = m.account_id and s.relation_id = m.relation_id
where m.id = ?
limit 1
`

type GetMessageAndNameByIDRow struct {
	ID         int64
	NotifyType MessagesNotifyType
	MsgType    MessagesMsgType
	MsgContent string
	MsgExtend  json.RawMessage
	FileID     sql.NullInt64
	AccountID  sql.NullInt64
	Name       string
	NickName   string
	Avatar     string
	RlyMsgID   sql.NullInt64
	RelationID int64
	CreateAt   time.Time
	IsRevoke   bool
	IsTop      bool
	IsPin      bool
	PinTime    time.Time
	ReadIds    json.RawMessage
	IsDelete   int32
}

func (q *Queries) GetMessageAndNameByID(ctx context.Context, id int64) (*GetMessageAndNameByIDRow, error) {
	row := q.queryRow(ctx, q.getMessageAndNameByIDStmt, getMessageAndNameByID, id)
	var i GetMessageAndNameByIDRow
	err := row.Scan(
		&i.ID,
		&i.NotifyType,
		&i.MsgType,
		&i.MsgContent,
		&i.MsgExtend,
		&i.FileID,
		&i.AccountID,
		&i.Name,
		&i.NickName,
		&i.Avatar,
		&i.RlyMsgID,
		&i.RelationID,
		&i.CreateAt,
		&i.IsRevoke,
		&i.IsTop,
		&i.IsPin,
		&i.PinTime,
		&i.ReadIds,
		&i.IsDelete,
	)
	return &i, err
}

const getMessageByID = `-- name: GetMessageByID :one
select id, notify_type, msg_type, msg_content, coalesce(msg_extend,'[]'), file_id, account_id,
       rly_msg_id, relation_id, create_at, is_revoke, is_top, is_pin, pin_time, read_ids, is_delete
from messages
where id = ?
limit 1
`

func (q *Queries) GetMessageByID(ctx context.Context, id int64) (*Message, error) {
	row := q.queryRow(ctx, q.getMessageByIDStmt, getMessageByID, id)
	var i Message
	err := row.Scan(
		&i.ID,
		&i.NotifyType,
		&i.MsgType,
		&i.MsgContent,
		&i.MsgExtend,
		&i.FileID,
		&i.AccountID,
		&i.RlyMsgID,
		&i.RelationID,
		&i.CreateAt,
		&i.IsRevoke,
		&i.IsTop,
		&i.IsPin,
		&i.PinTime,
		&i.ReadIds,
		&i.IsDelete,
	)
	return &i, err
}

const getMessageInfoTx = `-- name: GetMessageInfoTx :one
SELECT m.id, msg_content, msg_extend,file_id, create_at,m.account_id,a.name,a.avatar,s.nick_name
FROM messages m
join accounts a on a.id = m.account_id
join settings s on s.account_id = a.id and s.relation_id = m.relation_id
WHERE m.id = LAST_INSERT_ID()
`

type GetMessageInfoTxRow struct {
	ID         int64
	MsgContent string
	MsgExtend  json.RawMessage
	FileID     sql.NullInt64
	CreateAt   time.Time
	AccountID  sql.NullInt64
	Name       string
	Avatar     string
	NickName   string
}

func (q *Queries) GetMessageInfoTx(ctx context.Context) (*GetMessageInfoTxRow, error) {
	row := q.queryRow(ctx, q.getMessageInfoTxStmt, getMessageInfoTx)
	var i GetMessageInfoTxRow
	err := row.Scan(
		&i.ID,
		&i.MsgContent,
		&i.MsgExtend,
		&i.FileID,
		&i.CreateAt,
		&i.AccountID,
		&i.Name,
		&i.Avatar,
		&i.NickName,
	)
	return &i, err
}

const getMsgDeleteById = `-- name: GetMsgDeleteById :one
select  is_delete
from messages
where id = ?
`

func (q *Queries) GetMsgDeleteById(ctx context.Context, id int64) (int32, error) {
	row := q.queryRow(ctx, q.getMsgDeleteByIdStmt, getMsgDeleteById, id)
	var is_delete int32
	err := row.Scan(&is_delete)
	return is_delete, err
}

const getMsgsByContent = `-- name: GetMsgsByContent :many
select m1.id,
       m1.notify_type,
       m1.msg_type,
       m1.msg_content,
       coalesce(m1.msg_extend,'[]'),
       m1.file_id,
       m1.account_id,
       a.name,
       a.avatar,
       s.nick_name,
       m1.relation_id,
       m1.create_at,
       m1.is_delete,
       count(*) over () as total
from messages m1
         join settings s on m1.relation_id = s.relation_id and s.account_id = ?
         join accounts a on a.id = m1.account_id
where (not is_revoke)
    and m1.msg_content like concat('%', ?, '%')
order by m1.create_at desc
    limit ? offset ?
`

type GetMsgsByContentParams struct {
	AccountID int64
	CONCAT    interface{}
	Limit     int32
	Offset    int32
}

type GetMsgsByContentRow struct {
	ID         int64
	NotifyType MessagesNotifyType
	MsgType    MessagesMsgType
	MsgContent string
	MsgExtend  json.RawMessage
	FileID     sql.NullInt64
	AccountID  sql.NullInt64
	Name       string
	Avatar     string
	NickName   string
	RelationID int64
	CreateAt   time.Time
	IsDelete   int32
	Total      interface{}
}

func (q *Queries) GetMsgsByContent(ctx context.Context, arg *GetMsgsByContentParams) ([]*GetMsgsByContentRow, error) {
	rows, err := q.query(ctx, q.getMsgsByContentStmt, getMsgsByContent,
		arg.AccountID,
		arg.CONCAT,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetMsgsByContentRow{}
	for rows.Next() {
		var i GetMsgsByContentRow
		if err := rows.Scan(
			&i.ID,
			&i.NotifyType,
			&i.MsgType,
			&i.MsgContent,
			&i.MsgExtend,
			&i.FileID,
			&i.AccountID,
			&i.Name,
			&i.Avatar,
			&i.NickName,
			&i.RelationID,
			&i.CreateAt,
			&i.IsDelete,
			&i.Total,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMsgsByContentAndRelation = `-- name: GetMsgsByContentAndRelation :many
select m1.id,
       m1.notify_type,
       m1.msg_type,
       m1.msg_content,
       coalesce(m1.msg_extend,'[]'),
       m1.file_id,
       m1.account_id,
       a.name,
       a.avatar,
       s.nick_name,
       m1.relation_id,
       m1.create_at,
       m1.is_delete,
       count(*) over () as total
from messages m1
         join settings s on m1.relation_id = ? and m1.relation_id = s.relation_id and s.account_id = ?
         join accounts a on a.id = m1.account_id
where (not is_revoke)
  and m1.msg_content like concat('%', ?, '%')
order by m1.create_at desc
limit ? offset ?
`

type GetMsgsByContentAndRelationParams struct {
	RelationID int64
	AccountID  int64
	CONCAT     interface{}
	Limit      int32
	Offset     int32
}

type GetMsgsByContentAndRelationRow struct {
	ID         int64
	NotifyType MessagesNotifyType
	MsgType    MessagesMsgType
	MsgContent string
	MsgExtend  json.RawMessage
	FileID     sql.NullInt64
	AccountID  sql.NullInt64
	Name       string
	Avatar     string
	NickName   string
	RelationID int64
	CreateAt   time.Time
	IsDelete   int32
	Total      interface{}
}

func (q *Queries) GetMsgsByContentAndRelation(ctx context.Context, arg *GetMsgsByContentAndRelationParams) ([]*GetMsgsByContentAndRelationRow, error) {
	rows, err := q.query(ctx, q.getMsgsByContentAndRelationStmt, getMsgsByContentAndRelation,
		arg.RelationID,
		arg.AccountID,
		arg.CONCAT,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetMsgsByContentAndRelationRow{}
	for rows.Next() {
		var i GetMsgsByContentAndRelationRow
		if err := rows.Scan(
			&i.ID,
			&i.NotifyType,
			&i.MsgType,
			&i.MsgContent,
			&i.MsgExtend,
			&i.FileID,
			&i.AccountID,
			&i.Name,
			&i.Avatar,
			&i.NickName,
			&i.RelationID,
			&i.CreateAt,
			&i.IsDelete,
			&i.Total,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMsgsByRelationIDAndTime = `-- name: GetMsgsByRelationIDAndTime :many
select m1.id,
       m1.notify_type,
       m1.msg_type,
       m1.msg_content,
       coalesce(m1.msg_extend,'[]'),
       m1.file_id,
       m1.account_id,
       a.name,
       a.avatar,
       m1.rly_msg_id,
       m1.relation_id,
       m1.create_at,
       m1.is_revoke,
       m1.is_top,
       m1.is_pin,
       m1.pin_time,
       m1.read_ids,
       m1.is_delete,
       count(*) over () as total,
       (select count(id) from messages where rly_msg_id = m1.id and messages.relation_id = ?) as reply_count,
       s.nick_name
from messages m1
join accounts a on a.id = m1.account_id
join settings  s on s.account_id = m1.account_id and s.relation_id = m1.relation_id
where m1.relation_id = ?
  and m1.create_at < ?
order by m1.create_at desc
limit ? offset ?
`

type GetMsgsByRelationIDAndTimeParams struct {
	RelationID   int64
	RelationID_2 int64
	CreateAt     time.Time
	Limit        int32
	Offset       int32
}

type GetMsgsByRelationIDAndTimeRow struct {
	ID         int64
	NotifyType MessagesNotifyType
	MsgType    MessagesMsgType
	MsgContent string
	MsgExtend  json.RawMessage
	FileID     sql.NullInt64
	AccountID  sql.NullInt64
	Name       string
	Avatar     string
	RlyMsgID   sql.NullInt64
	RelationID int64
	CreateAt   time.Time
	IsRevoke   bool
	IsTop      bool
	IsPin      bool
	PinTime    time.Time
	ReadIds    json.RawMessage
	IsDelete   int32
	Total      interface{}
	ReplyCount int64
	NickName   string
}

func (q *Queries) GetMsgsByRelationIDAndTime(ctx context.Context, arg *GetMsgsByRelationIDAndTimeParams) ([]*GetMsgsByRelationIDAndTimeRow, error) {
	rows, err := q.query(ctx, q.getMsgsByRelationIDAndTimeStmt, getMsgsByRelationIDAndTime,
		arg.RelationID,
		arg.RelationID_2,
		arg.CreateAt,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetMsgsByRelationIDAndTimeRow{}
	for rows.Next() {
		var i GetMsgsByRelationIDAndTimeRow
		if err := rows.Scan(
			&i.ID,
			&i.NotifyType,
			&i.MsgType,
			&i.MsgContent,
			&i.MsgExtend,
			&i.FileID,
			&i.AccountID,
			&i.Name,
			&i.Avatar,
			&i.RlyMsgID,
			&i.RelationID,
			&i.CreateAt,
			&i.IsRevoke,
			&i.IsTop,
			&i.IsPin,
			&i.PinTime,
			&i.ReadIds,
			&i.IsDelete,
			&i.Total,
			&i.ReplyCount,
			&i.NickName,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getNickNameByAccountIDAndRelation = `-- name: GetNickNameByAccountIDAndRelation :one
select nick_name
from settings
where account_id = ?
  and relation_id = ?
`

type GetNickNameByAccountIDAndRelationParams struct {
	AccountID  int64
	RelationID int64
}

func (q *Queries) GetNickNameByAccountIDAndRelation(ctx context.Context, arg *GetNickNameByAccountIDAndRelationParams) (string, error) {
	row := q.queryRow(ctx, q.getNickNameByAccountIDAndRelationStmt, getNickNameByAccountIDAndRelation, arg.AccountID, arg.RelationID)
	var nick_name string
	err := row.Scan(&nick_name)
	return nick_name, err
}

const getPinMsgsByRelationID = `-- name: GetPinMsgsByRelationID :many
select m1.id,
       m1.notify_type,
       m1.msg_type,
       m1.msg_content,
       coalesce(m1.msg_extend,'[]'),
       m1.file_id,
       m1.account_id,
       m1.relation_id,
       m1.create_at,
       m1.is_revoke,
       m1.is_top,
       m1.is_pin,
       m1.pin_time,
       m1.read_ids,
       m1.is_delete,
       (select count(id) from messages where rly_msg_id = m1.id and messages.relation_id = ?) as reply_count,
       count(*) over () as total
from messages m1
where m1.relation_id = ? and m1.is_pin = true
order by m1.pin_time desc
limit ? offset ?
`

type GetPinMsgsByRelationIDParams struct {
	RelationID   int64
	RelationID_2 int64
	Limit        int32
	Offset       int32
}

type GetPinMsgsByRelationIDRow struct {
	ID         int64
	NotifyType MessagesNotifyType
	MsgType    MessagesMsgType
	MsgContent string
	MsgExtend  json.RawMessage
	FileID     sql.NullInt64
	AccountID  sql.NullInt64
	RelationID int64
	CreateAt   time.Time
	IsRevoke   bool
	IsTop      bool
	IsPin      bool
	PinTime    time.Time
	ReadIds    json.RawMessage
	IsDelete   int32
	ReplyCount int64
	Total      interface{}
}

func (q *Queries) GetPinMsgsByRelationID(ctx context.Context, arg *GetPinMsgsByRelationIDParams) ([]*GetPinMsgsByRelationIDRow, error) {
	rows, err := q.query(ctx, q.getPinMsgsByRelationIDStmt, getPinMsgsByRelationID,
		arg.RelationID,
		arg.RelationID_2,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetPinMsgsByRelationIDRow{}
	for rows.Next() {
		var i GetPinMsgsByRelationIDRow
		if err := rows.Scan(
			&i.ID,
			&i.NotifyType,
			&i.MsgType,
			&i.MsgContent,
			&i.MsgExtend,
			&i.FileID,
			&i.AccountID,
			&i.RelationID,
			&i.CreateAt,
			&i.IsRevoke,
			&i.IsTop,
			&i.IsPin,
			&i.PinTime,
			&i.ReadIds,
			&i.IsDelete,
			&i.ReplyCount,
			&i.Total,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRlyMsgsInfoByMsgID = `-- name: GetRlyMsgsInfoByMsgID :many
select m1.id,
       m1.notify_type,
       m1.msg_type,
       m1.msg_content,
       coalesce(m1.msg_extend,'[]'),
       m1.file_id,
       m1.account_id,
       a.name,
       a.avatar,
       s.nick_name,
       m1.relation_id,
       m1.create_at,
       m1.is_revoke,
       m1.is_top,
       m1.is_pin,
       m1.pin_time,
       m1.read_ids,
       m1.is_delete,
       (select count(id) from messages where rly_msg_id = m1.id and messages.relation_id = ?) as reply_count,
       count(*) over () as total
from messages m1
join settings s on m1.relation_id = s.relation_id and s.account_id = m1.account_id
join accounts a on a.id = m1.account_id
where m1.relation_id = ? and m1.rly_msg_id = ?
order by m1.create_at
limit ? offset ?
`

type GetRlyMsgsInfoByMsgIDParams struct {
	RelationID   int64
	RelationID_2 int64
	RlyMsgID     sql.NullInt64
	Limit        int32
	Offset       int32
}

type GetRlyMsgsInfoByMsgIDRow struct {
	ID         int64
	NotifyType MessagesNotifyType
	MsgType    MessagesMsgType
	MsgContent string
	MsgExtend  json.RawMessage
	FileID     sql.NullInt64
	AccountID  sql.NullInt64
	Name       string
	Avatar     string
	NickName   string
	RelationID int64
	CreateAt   time.Time
	IsRevoke   bool
	IsTop      bool
	IsPin      bool
	PinTime    time.Time
	ReadIds    json.RawMessage
	IsDelete   int32
	ReplyCount int64
	Total      interface{}
}

func (q *Queries) GetRlyMsgsInfoByMsgID(ctx context.Context, arg *GetRlyMsgsInfoByMsgIDParams) ([]*GetRlyMsgsInfoByMsgIDRow, error) {
	rows, err := q.query(ctx, q.getRlyMsgsInfoByMsgIDStmt, getRlyMsgsInfoByMsgID,
		arg.RelationID,
		arg.RelationID_2,
		arg.RlyMsgID,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetRlyMsgsInfoByMsgIDRow{}
	for rows.Next() {
		var i GetRlyMsgsInfoByMsgIDRow
		if err := rows.Scan(
			&i.ID,
			&i.NotifyType,
			&i.MsgType,
			&i.MsgContent,
			&i.MsgExtend,
			&i.FileID,
			&i.AccountID,
			&i.Name,
			&i.Avatar,
			&i.NickName,
			&i.RelationID,
			&i.CreateAt,
			&i.IsRevoke,
			&i.IsTop,
			&i.IsPin,
			&i.PinTime,
			&i.ReadIds,
			&i.IsDelete,
			&i.ReplyCount,
			&i.Total,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTopMsgByRelationID = `-- name: GetTopMsgByRelationID :one
select m1.id,
       m1.notify_type,
       m1.msg_type,
       m1.msg_content,
       coalesce(m1.msg_extend,'[]'),
       m1.file_id,
       m1.account_id,
       m1.relation_id,
       m1.create_at,
       m1.is_revoke,
       m1.is_top,
       m1.is_pin,
       m1.pin_time,
       m1.read_ids,
       (select count(id) from messages where rly_msg_id = m1.id and messages.relation_id = ?) as reply_count,
       count(*) over () as total
from messages m1
where m1.relation_id = ? and m1.is_top = true
limit 1
`

type GetTopMsgByRelationIDParams struct {
	RelationID   int64
	RelationID_2 int64
}

type GetTopMsgByRelationIDRow struct {
	ID         int64
	NotifyType MessagesNotifyType
	MsgType    MessagesMsgType
	MsgContent string
	MsgExtend  json.RawMessage
	FileID     sql.NullInt64
	AccountID  sql.NullInt64
	RelationID int64
	CreateAt   time.Time
	IsRevoke   bool
	IsTop      bool
	IsPin      bool
	PinTime    time.Time
	ReadIds    json.RawMessage
	ReplyCount int64
	Total      interface{}
}

func (q *Queries) GetTopMsgByRelationID(ctx context.Context, arg *GetTopMsgByRelationIDParams) (*GetTopMsgByRelationIDRow, error) {
	row := q.queryRow(ctx, q.getTopMsgByRelationIDStmt, getTopMsgByRelationID, arg.RelationID, arg.RelationID_2)
	var i GetTopMsgByRelationIDRow
	err := row.Scan(
		&i.ID,
		&i.NotifyType,
		&i.MsgType,
		&i.MsgContent,
		&i.MsgExtend,
		&i.FileID,
		&i.AccountID,
		&i.RelationID,
		&i.CreateAt,
		&i.IsRevoke,
		&i.IsTop,
		&i.IsPin,
		&i.PinTime,
		&i.ReadIds,
		&i.ReplyCount,
		&i.Total,
	)
	return &i, err
}

const offerMsgsByAccountIDAndTime = `-- name: OfferMsgsByAccountIDAndTime :many
select m1.id,
       m1.notify_type,
       m1.msg_type,
       m1.msg_content,
       coalesce(m1.msg_extend,'[]'),
       m1.file_id,
       m1.account_id,
       m1.rly_msg_id,
       m1.relation_id,
       m1.create_at,
       m1.is_revoke,
       m1.is_top,
       m1.is_pin,
       m1.pin_time,
       m1.read_ids,
       m1.is_delete,
       count(*) over () as total,
       (select count(id) from messages where rly_msg_id = m1.id and messages.relation_id = m1.relation_id) as reply_count
from messages m1
         join settings s on m1.relation_id = s.relation_id and s.account_id = ?
where m1.create_at > ?
limit ? offset ?
`

type OfferMsgsByAccountIDAndTimeParams struct {
	AccountID int64
	CreateAt  time.Time
	Limit     int32
	Offset    int32
}

type OfferMsgsByAccountIDAndTimeRow struct {
	ID         int64
	NotifyType MessagesNotifyType
	MsgType    MessagesMsgType
	MsgContent string
	MsgExtend  json.RawMessage
	FileID     sql.NullInt64
	AccountID  sql.NullInt64
	RlyMsgID   sql.NullInt64
	RelationID int64
	CreateAt   time.Time
	IsRevoke   bool
	IsTop      bool
	IsPin      bool
	PinTime    time.Time
	ReadIds    json.RawMessage
	IsDelete   int32
	Total      interface{}
	ReplyCount int64
}

func (q *Queries) OfferMsgsByAccountIDAndTime(ctx context.Context, arg *OfferMsgsByAccountIDAndTimeParams) ([]*OfferMsgsByAccountIDAndTimeRow, error) {
	rows, err := q.query(ctx, q.offerMsgsByAccountIDAndTimeStmt, offerMsgsByAccountIDAndTime,
		arg.AccountID,
		arg.CreateAt,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*OfferMsgsByAccountIDAndTimeRow{}
	for rows.Next() {
		var i OfferMsgsByAccountIDAndTimeRow
		if err := rows.Scan(
			&i.ID,
			&i.NotifyType,
			&i.MsgType,
			&i.MsgContent,
			&i.MsgExtend,
			&i.FileID,
			&i.AccountID,
			&i.RlyMsgID,
			&i.RelationID,
			&i.CreateAt,
			&i.IsRevoke,
			&i.IsTop,
			&i.IsPin,
			&i.PinTime,
			&i.ReadIds,
			&i.IsDelete,
			&i.Total,
			&i.ReplyCount,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateMsgDelete = `-- name: UpdateMsgDelete :exec
update messages
set is_delete = ?
where id = ?
`

type UpdateMsgDeleteParams struct {
	IsDelete int32
	ID       int64
}

func (q *Queries) UpdateMsgDelete(ctx context.Context, arg *UpdateMsgDeleteParams) error {
	_, err := q.exec(ctx, q.updateMsgDeleteStmt, updateMsgDelete, arg.IsDelete, arg.ID)
	return err
}

const updateMsgPin = `-- name: UpdateMsgPin :exec
update messages
set is_pin = ?
where id = ?
`

type UpdateMsgPinParams struct {
	IsPin bool
	ID    int64
}

func (q *Queries) UpdateMsgPin(ctx context.Context, arg *UpdateMsgPinParams) error {
	_, err := q.exec(ctx, q.updateMsgPinStmt, updateMsgPin, arg.IsPin, arg.ID)
	return err
}

const updateMsgRevoke = `-- name: UpdateMsgRevoke :exec
update messages
set is_revoke = ?
where id = ?
`

type UpdateMsgRevokeParams struct {
	IsRevoke bool
	ID       int64
}

func (q *Queries) UpdateMsgRevoke(ctx context.Context, arg *UpdateMsgRevokeParams) error {
	_, err := q.exec(ctx, q.updateMsgRevokeStmt, updateMsgRevoke, arg.IsRevoke, arg.ID)
	return err
}

const updateMsgTop = `-- name: UpdateMsgTop :exec
update messages
set is_top = ?
where id = ?
`

type UpdateMsgTopParams struct {
	IsTop bool
	ID    int64
}

func (q *Queries) UpdateMsgTop(ctx context.Context, arg *UpdateMsgTopParams) error {
	_, err := q.exec(ctx, q.updateMsgTopStmt, updateMsgTop, arg.IsTop, arg.ID)
	return err
}
